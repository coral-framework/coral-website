{"name":"co","datetime":"2014-04-03 19:52:21","types":[{"name":"co.ArrayType","kind":"component","doc":"\n\n\tImplements co.IArray.\n\t---\n\ttags: private type-introspection\n ","members":[{"kind":"facet","name":"type","type":"co.IArray","doc":""}]},{"name":"co.Component","kind":"component","doc":"\n\n\tImplements co.IComponent.\n\t---\n\ttags: private type-introspection\n ","members":[{"kind":"facet","name":"type","type":"co.IComponent","doc":""}]},{"name":"co.CppBlockAnnotation","kind":"component","doc":"\n\n\tProvides the special @co.CppBlock annotation.\n\t---\n\ttags: private type-introspection\n ","members":[{"kind":"facet","name":"annotation","type":"co.ICppBlock","doc":""}]},{"name":"co.CSLError","kind":"struct","doc":"\n\n\tContextual information about why a type could not be loaded.\n\t---\n\ttags: deprecated\n ","members":[{"kind":"field","name":"filename","type":"string","isReadOnly":false,"doc":" Full path to the CSL file."},{"kind":"field","name":"line","type":"int32","isReadOnly":false,"doc":" Line where the error occurred."},{"kind":"field","name":"message","type":"string","isReadOnly":false,"doc":" Error message."}]},{"name":"co.DocumentationAnnotation","kind":"component","doc":"\n\n\tProvides the special @co.Documentation annotation.\n\t---\n\ttags: private type-introspection\n ","members":[{"kind":"facet","name":"annotation","type":"co.IDocumentation","doc":""}]},{"name":"co.Enum","kind":"component","doc":"\n\n\tImplements co.IEnum.\n\t---\n\ttags: private type-introspection\n ","members":[{"kind":"facet","name":"type","type":"co.IEnum","doc":""}]},{"name":"co.ExceptionType","kind":"component","doc":"\n\n\tImplements co.IException.\n\t---\n\ttags: private type-introspection\n ","members":[{"kind":"facet","name":"type","type":"co.IException","doc":""}]},{"name":"co.Field","kind":"component","doc":"\n\n\tImplements co.IField.\n\t---\n\ttags: private type-introspection\n ","members":[{"kind":"facet","name":"field","type":"co.IField","doc":""}]},{"name":"co.IAnnotated","kind":"interface","doc":"\n\n\tBase interface for services that can be annotated.\n\n\tAn annotated service may contain any number of #annotations.\n\n\tUse #findAnnotation to get an annotation of a certain type.\n\tFor example, in Lua:\n\n\t``` lua\n\tlocal annotation = svc:findAnnotation( co.Type \"my.IAnnotationType\" )\n\t```\n\n\tAnd in C++, for convenience, you may pass the type as a template argument:\n\n\t``` cpp\n\tco::IAnnotationRef a = svc->findAnnotation<my::IAnnotationType>();\n\t```\n\n\t---\n\ttags: type-annotation\n ","base":"co.IService","members":[{"kind":"field","name":"annotations","type":"co.IAnnotation[]","isReadOnly":false,"doc":"\n List of annotations on this service."},{"kind":"method","name":"addAnnotation","returnType":"void","doc":"\n\n\t\tAdds an annotation onto this service.\n\n\t\tRaises co.IllegalArgumentException if `annotation` is invalid.\n\t ","parameters":[{"name":"annotation","type":"co.IAnnotation","mode":"in"}],"exceptions":["co.IllegalArgumentException"]},{"kind":"method","name":"findAnnotation","returnType":"co.IAnnotation","doc":"\n\n\t\tFinds the first annotation of a given type.\n\n\t\tReturns null if no annotation of type `annotationType` is found.\n\n\t\tRaises co.IllegalArgumentException if `annotationType` is invalid.\n\t ","parameters":[{"name":"annotationType","type":"co.IInterface","mode":"in"}],"exceptions":["co.IllegalArgumentException"]}],"cpp":"\n\t\t// T isA co.IAnnotation\n\t\ttemplate<typename T> inline T* findAnnotation()\n\t\t{\n\t\t\treturn static_cast<T*>( findAnnotation( co::typeOf<T>::get() ) );\n\t\t}\n\t"},{"name":"co.IAnnotation","kind":"interface","doc":"\n\n\tBase interface for annotations. Decorates an annotated service.\n\n\tAlthough empty, this interface is useful for queries such as co.IType#isA.\n\n\t---\n\ttags: type-annotation\n ","base":"co.IService","members":[],"cpp":""},{"name":"co.IArray","kind":"interface","doc":"\n\n\tDescribes an array type.\n\n\tRepresents a one-dimensional array of #elementType.\n\n\t---\n\ttags: type-introspection\n ","base":"co.IType","members":[{"kind":"field","name":"elementType","type":"co.IType","isReadOnly":true,"doc":"\n Array element type."}],"cpp":""},{"name":"co.IClassType","kind":"interface","doc":"\n\n\tInterface for types that have methods.\n\n\t---\n\ttags: type-introspection\n ","base":"co.IRecordType","members":[{"kind":"field","name":"methods","type":"co.IMethod[]","isReadOnly":true,"doc":"\n List of member methods."}],"cpp":""},{"name":"co.IComponent","kind":"interface","doc":"\n\n\tDescribes a component type.\n\n\t---\n\ttags: type-introspection\n ","base":"co.ICompositeType","members":[{"kind":"field","name":"facets","type":"co.IPort[]","isReadOnly":true,"doc":"\n List of facets (ports that _provide_ services)."},{"kind":"field","name":"ports","type":"co.IPort[]","isReadOnly":true,"doc":"\n List of all component ports (both facets and receptacles)."},{"kind":"field","name":"receptacles","type":"co.IPort[]","isReadOnly":true,"doc":"\n List of receptacles (ports for _consuming_ services)."}],"cpp":""},{"name":"co.ICompositeType","kind":"interface","doc":"\n\n\tInterface for types that have members.\n\n\t---\n\ttags: type-introspection\n ","base":"co.IType","members":[{"kind":"field","name":"members","type":"co.IMember[]","isReadOnly":true,"doc":"\n\n\t\tList of local members (fields, methods, ports, etc.).\n\n\t\tThis excludes inherited members. See #getMember.\n\t "},{"kind":"method","name":"getMember","returnType":"co.IMember","doc":"\n\n\t\tFinds a member by name, considering inherited members.\n\n\t\tReturns null if no member is found with the given `name`.\n\t ","parameters":[{"name":"name","type":"string","mode":"in"}],"exceptions":[]}],"cpp":""},{"name":"co.ICppBlock","kind":"interface","doc":"\n\n\tContains C++ code for interfaces and native classes in CSL.\n\n\tFor example, the following interface would be annotated with a\n\tco.ICppBlock containg `// hello`:\n\n\t``` csl\n\tinterface ISample\n\t{\n\t\t<c++\n\t\t\t// hello\n\t\tc++>\n\t};\n\t```\n\n\t---\n\ttags: type-annotation\n ","base":"co.IAnnotation","members":[{"kind":"field","name":"value","type":"string","isReadOnly":false,"doc":"\n C++ code."}],"cpp":""},{"name":"co.IDocumentation","kind":"interface","doc":"\n\n\tContains documentation for types in CSL.\n\n\tKeeps the type's documentation in #value and offers two methods for\n\tstoring and retrieving additional documentation by member name.\n\n\t---\n\ttags: type-annotation\n ","base":"co.IAnnotation","members":[{"kind":"field","name":"value","type":"string","isReadOnly":false,"doc":"\n Type documentation."},{"kind":"method","name":"addDocFor","returnType":"void","doc":"\n\n\t\tAdds documentation for `member`.\n\n\t\tAppends `doc` to any pre-existing documentation for `member`.\n\t ","parameters":[{"name":"member","type":"string","mode":"in"},{"name":"doc","type":"string","mode":"in"}],"exceptions":[]},{"kind":"method","name":"getDocFor","returnType":"string","doc":"\n\n\t\tGets documentation for `member`.\n\n\t\tReturns an empty string if `member` has no documentation.\n\t","parameters":[{"name":"member","type":"string","mode":"in"}],"exceptions":[]}],"cpp":""},{"name":"co.IDynamicServiceProvider","kind":"interface","doc":"\n\n\tAllows an object to provide new services at runtime via _dynamic proxies_.\n\n\t**This interface can only be implemented in C++.**\n\n\tA _dynamic proxy_ is a service that uses reflection to delegate calls to a\n\tco.IDynamicServiceProvider. The provider handles all field and method calls\n\tfor its proxies via #dynamicGetField, #dynamicSetField and #dynamicInvoke.\n\n\tA proxy is created by calling co.IReflector#newDynamicProxy on an interface\n\treflector. For example, in order to provide a service of type `bar.IFoo`\n\tat runtime, an object may create a proxy for itself like this:\n\n\t``` cpp\n\tco::getType( \"bar.IFoo\" )->getReflector()->newDynamicProxy( this );\n\t```\n\n\tThe created proxy will call #dynamicRegisterService from its constructor.\n\tIn this call the _provider_ must save a pointer to the proxy---which it\n\tmust _delete_ at some point---and assign an _id >= 0_ to identify the\n\tproxy in all future calls.\n\n\tCurrently the only safe place to _delete_ a proxy is in the provider's\n\tdestructor.\t**Per-proxy reference counting is not currently supported,\n\tbut this will be fixed in the next release.**\n\n\t---\n\ttags: component-model\n ","base":"co.IService","members":[{"kind":"method","name":"dynamicGetFacet","returnType":"co.IPort","doc":"\n\n\t\tCalled when the port through which a proxy is provided is requested.\n\n\t\t**Currently this means a new component type must be defined for every\n\t\tdynamic object layout, which is very limiting. In the next release\n\t\twe will allow for every single object to have a unique set of ports.**\n\t ","parameters":[{"name":"proxyId","type":"int32","mode":"in"}],"exceptions":[]},{"kind":"method","name":"dynamicGetField","returnType":"void","doc":"\n\n\t\tCalled when a proxy needs to get the value of a `field`.\n\n\t\tThis method should put the field's value into `var`.\n\t ","parameters":[{"name":"proxyId","type":"int32","mode":"in"},{"name":"field","type":"co.IField","mode":"in"},{"name":"var","type":"any","mode":"in"}],"exceptions":[]},{"kind":"method","name":"dynamicInvoke","returnType":"void","doc":"\n\n\t\tCalled when a proxy has a `method` invoked.\n\n\t\tArguments in `args` are in direct order and honor _out_ variables.\n\n\t\tThis method must obey the invoked method's contract. It should put\n\t\tthe method's return value (if any) into `retVal` and any additional\n\t\toutput values into the corresponding variables in `args`.\n\t ","parameters":[{"name":"proxyId","type":"int32","mode":"in"},{"name":"method","type":"co.IMethod","mode":"in"},{"name":"args","type":"any[]","mode":"in"},{"name":"retVal","type":"any","mode":"in"}],"exceptions":[]},{"kind":"method","name":"dynamicRegisterService","returnType":"int32","doc":"\n\n\t\tCalled when a new `proxy` service is created for this provider.\n\n\t\tThis method is called from within the constructor of a proxy\n\t\tcreated for this provider. It must save a raw pointer to the proxy\n\t\tand return an _id >= 0_ to identify the proxy in all future calls.\n\t ","parameters":[{"name":"proxy","type":"co.IService","mode":"in"}],"exceptions":[]},{"kind":"method","name":"dynamicSetField","returnType":"void","doc":"\n\n\t\tCalled when a proxy needs to set the value of a `field`.\n\n\t\tThis method should set the field's value to `value`.\n\t ","parameters":[{"name":"proxyId","type":"int32","mode":"in"},{"name":"field","type":"co.IField","mode":"in"},{"name":"value","type":"any","mode":"in"}],"exceptions":[]}],"cpp":""},{"name":"co.IDynamicTypeProvider","kind":"interface","doc":"\n\n\tBase interface for annotations that make a type _dynamic_.\n\n\tA _dynamic type_ doesn't require source code generation and is ignored by\n\tthe Coral compiler. The framework obtains the type's reflector from this\n\tannotation, instead of the type's module. Thus a dynamic type can be\n\tinstantiated without even having a module.\n\n\t---\n\ttags: type-annotation\n ","base":"co.IAnnotation","members":[{"kind":"method","name":"provideReflectorFor","returnType":"void","doc":"\n\n\t\tProvides a reflector for `type`.\n\n\t\t**Precondition:** type's co.IType#currentReflector is null.\n\n\t\t**Postcondition:** type's co.IType#currentReflector is *not* null.\n\n\t\tRaises co.NotSupportedException on failure to set the type's reflector.\n\t ","parameters":[{"name":"type","type":"co.IType","mode":"in"}],"exceptions":["co.NotSupportedException"]}],"cpp":""},{"name":"co.IEnum","kind":"interface","doc":"\n\n\tDescribes an enum type.\n\n\tContains a list of #identifiers with _implicit values_ from 0 to n-1.\n\n\t---\n\ttags: type-introspection\n ","base":"co.IType","members":[{"kind":"field","name":"identifiers","type":"string[]","isReadOnly":true,"doc":"\n List of identifiers."},{"kind":"method","name":"getValueOf","returnType":"int32","doc":"\n\n\t\tFinds an identifier and returns its value.\n\n\t\tReturns -1 if `id` is not a valid identifier.\n\t\tValid results are in the range [0, n-1].\n\t ","parameters":[{"name":"id","type":"string","mode":"in"}],"exceptions":[]}],"cpp":""},{"name":"co.IException","kind":"interface","doc":"\n\n\tDescribes an exception type.\n\n\tRepresents an exception raised by methods.\n\n\t---\n\ttags: type-introspection\n ","base":"co.IType","members":[],"cpp":""},{"name":"co.IField","kind":"interface","doc":"\n\n\tDescribes a field as a member of a co.IRecordType.\n\n\t---\n\ttags: type-introspection\n ","base":"co.IMember","members":[{"kind":"field","name":"isReadOnly","type":"bool","isReadOnly":true,"doc":"\n Whether the field is read-only (true) or read-write (false)."},{"kind":"field","name":"type","type":"co.IType","isReadOnly":true,"doc":"\n Field type."}],"cpp":""},{"name":"co.IInclude","kind":"interface","doc":"\n\n\tStates a header file must be included in order to use a native class.\n\n\tThe preferred approach for simple native classes in Coral is to fully\n\tdefine the C++ type inside the native class in CSL.\n\n\tHowever, for non-trivial native classes, this approach may cause problems\n\twith circular dependencies and slow down build times. In C++ the solution\n\tin these situations is to use _forward declarations_ as much as possible,\n\tand only include the full type definition at the last moment.\n\tThis is exactly what this annotation allows you to do!\n\n\tTo define a native class that uses forward declaration as much as possible:\n\n\t1. The C++ code inside the native class should be a forward declaration.\n\t2. Use this annotation to indicate which header should be included.\n\n\tFor example, to create a native class `MyValue` in module `mymodule` as\n\ta forward declaration to `mylib::RealClass`:\n\n\t``` csl\n\t@co.Include(\"myLib/RealClass.h\")\n\tnative class MyValue\n\t{\n\t\t<c++\n\t\t\tnamespace mylib { class RealClass; }\n\t\t\tnamespace mymodule { typedef myLib::RealClass MyValue; }\n\t\tc++>\n\t}\n\t```\n\n\tThis annotation is implemented by co.IncludeAnnotation.\n\n\t---\n\ttags: type-annotation\n ","base":"co.IAnnotation","members":[{"kind":"field","name":"value","type":"string","isReadOnly":false,"doc":"\n C++ header name."}],"cpp":""},{"name":"co.IInterface","kind":"interface","doc":"\n\n\tDescribes an interface type.\n\n\tInterfaces support single inheritance and extend co.IService by default.\n\tIn other words, every interface extends another interface---except for\n\tco.IService, which is the root of the hierarchy and has a null #baseType.\n\n\t---\n\ttags: type-introspection\n ","base":"co.IClassType","members":[{"kind":"field","name":"baseType","type":"co.IInterface","isReadOnly":true,"doc":"\n Parent interface, or null if this interface is co.IService."},{"kind":"field","name":"subTypes","type":"co.IInterface[]","isReadOnly":true,"doc":"\n List of interfaces that directly extend this interface."},{"kind":"field","name":"superTypes","type":"co.IInterface[]","isReadOnly":true,"doc":"\n List of ancestors. Starts with #baseType and goes up to co.IService."}],"cpp":""},{"name":"co.IllegalArgumentException","kind":"exception","doc":"\n\n\tRaised when a method is passed an illegal argument.\n\t---\n\ttags: exception\n "},{"name":"co.IllegalCastException","kind":"exception","doc":"\n\n\tRaised when a type cast or a value conversion fails.\n\t---\n\ttags: exception\n "},{"name":"co.IllegalNameException","kind":"exception","doc":"\n\n\tRaised when a name is illegal.\n\t---\n\ttags: exception\n "},{"name":"co.IllegalStateException","kind":"exception","doc":"\n\n\tRaised when something is in an unexpected or illegal state.\n\t---\n\ttags: exception\n "},{"name":"co.IMember","kind":"interface","doc":"\n\n\tInterface for members of a co.ICompositeType.\n\n\tEach type member has a unique #name within its #owner's hierarchy.\n\n\t---\n\ttags: type-introspection\n ","base":"co.IAnnotated","members":[{"kind":"field","name":"index","type":"uint16","isReadOnly":true,"doc":"\n Index of the member within its type's co.ICompositeType#members array."},{"kind":"field","name":"kind","type":"co.MemberKind","isReadOnly":true,"doc":"\n Member kind (field, method or port)."},{"kind":"field","name":"name","type":"string","isReadOnly":true,"doc":"\n Member name."},{"kind":"field","name":"owner","type":"co.ICompositeType","isReadOnly":true,"doc":"\n Type that contains this member."}],"cpp":""},{"name":"co.IMethod","kind":"interface","doc":"\n\n\tDescribes a method as a member of a co.IClassType.\n\n\t---\n\ttags: type-introspection\n ","base":"co.IMember","members":[{"kind":"field","name":"exceptions","type":"co.IException[]","isReadOnly":true,"doc":"\n List of raised exceptions."},{"kind":"field","name":"parameters","type":"co.IParameter[]","isReadOnly":true,"doc":"\n List of method parameters."},{"kind":"field","name":"returnType","type":"co.IType","isReadOnly":true,"doc":"\n The method's return type, or null if `void`."}],"cpp":""},{"name":"co.IMethodBuilder","kind":"interface","doc":"\n\n\tAssists in the definition of a method for a new Coral type.\n\n\tThe workflow for defining a new method is as follows:\n\n\t1. Create a method builder by calling co.ITypeBuilder#defineMethod on\n\ta co.ITypeBuilder.\n\t2. Use the methods below to specify the method signature.\n\t3. Call #createMethod to add the method to the type builder.\n\n\t---\n\ttags: type-creation\n ","base":"co.IService","members":[{"kind":"field","name":"methodName","type":"string","isReadOnly":true,"doc":"\n Name of the method being defined."},{"kind":"field","name":"typeBuilder","type":"co.ITypeBuilder","isReadOnly":true,"doc":"\n Type builder for which the method is being defined."},{"kind":"method","name":"createMethod","returnType":"void","doc":"\n\n\t\tCreates the method into #typeBuilder.\n\n\t\tRaises co.IllegalNameException if `methodName` clashes with something.\n\t\tRaises co.NotSupportedException if the type was already created.\n\t ","parameters":[],"exceptions":["co.IllegalNameException","co.NotSupportedException"]},{"kind":"method","name":"defineException","returnType":"void","doc":"\n\n\t\tAdds an exception raised by the method.\n\n\t\tRaises co.IllegalArgumentException if `exceptionType` is invalid.\n\t ","parameters":[{"name":"exceptionType","type":"co.IException","mode":"in"}],"exceptions":["co.IllegalArgumentException"]},{"kind":"method","name":"defineParameter","returnType":"void","doc":"\n\n\t\tAdds a method parameter.\n\n\t\tRaises co.IllegalNameException if `name` is invalid.\n\t\tRaises co.IllegalArgumentException if `type` is invalid.\n\t\tRaises co.IllegalArgumentException if `isIn` and `isOut` are both false.\n\t ","parameters":[{"name":"name","type":"string","mode":"in"},{"name":"type","type":"co.IType","mode":"in"},{"name":"isIn","type":"bool","mode":"in"},{"name":"isOut","type":"bool","mode":"in"}],"exceptions":["co.IllegalNameException","co.IllegalArgumentException"]},{"kind":"method","name":"defineReturnType","returnType":"void","doc":"\n\n\t\tDefines the method's return type.\n\n\t\tRaises co.IllegalArgumentException if `type` is invalid.\n\t\tRaises co.NotSupportedException if a return type was already defined.\n\t ","parameters":[{"name":"type","type":"co.IType","mode":"in"}],"exceptions":["co.IllegalArgumentException","co.NotSupportedException"]}],"cpp":""},{"name":"co.IModule","kind":"interface","doc":"\n\n\tA collection of types and resources.\n\n\tA module consists in a set of #parts loaded from a #namespace. Each module\n\tpart represents an artifact---such as a library, script or data file---that\n\tadds functionality to the system.\n\n\tModules and their #parts share the same _life cycle_, which is intertwined\n\twith the system's life cycle. Whenever the system changes state it updates\n\tall modules, and whenever a module changes state it updates its #parts.\n\n\tModules must respond to five life-cycle events:\n\n\t1. In #initialize modules should publish services and set reflectors for\n\tall their types. During this event a module cannot do anything that\n\trequires other modules---it should wait until #integrate.\n\t2. In #integrate modules may query and use services from other modules.\n\t3. In #integratePresentation modules can integrate presentation elements.\n\t4. In #disintegrate modules should release all external references.\n\t5. In #dispose modules should free all allocated resources.\n\n\tThe system will #abort a module if any event raises an exception.\n\n\t---\n\ttags: module-system\n ","base":"co.IService","members":[{"kind":"field","name":"namespace","type":"co.INamespace","isReadOnly":true,"doc":"\n Namespace where the module is located."},{"kind":"field","name":"parts","type":"co.IModulePart[]","isReadOnly":true,"doc":"\n List of parts that comprise the module."},{"kind":"field","name":"rank","type":"int32","isReadOnly":false,"doc":"\n\n\t\tAdjusts the order in which modules receive updates from the system.\n\n\t\tModules are sorted by increasing rank value. The default rank is zero.\n\t "},{"kind":"field","name":"state","type":"co.ModuleState","isReadOnly":true,"doc":"\n Current state of the module and all its #parts."},{"kind":"method","name":"abort","returnType":"void","doc":"\n\n\t\tAborts the module.\n\n\t\tIf the module was already integrated, this method calls #disintegrate.\n\n\t\tThis always calls #dispose and changes #state to `ModuleState_Aborted`.\n\n\t\tRaises co.IllegalStateException if the module was already disposed.\n\t ","parameters":[],"exceptions":["co.IllegalStateException"]},{"kind":"method","name":"disintegrate","returnType":"void","doc":"\n\n\t\tDisintegrates the module from the system.\n\n\t\tThis changes #state to `ModuleState_Disintegrated`.\n\n\t\tRaises co.IllegalStateException if #state isn't `ModuleState_PresentationIntegrated`.\n\t ","parameters":[],"exceptions":["co.IllegalStateException"]},{"kind":"method","name":"dispose","returnType":"void","doc":"\n\n\t\tDisposes the module.\n\n\t\tThis changes #state to `ModuleState_Disposed`.\n\n\t\tRaises co.IllegalStateException if #state isn't `ModuleState_Disintegrated`.\n\t ","parameters":[],"exceptions":["co.IllegalStateException"]},{"kind":"method","name":"initialize","returnType":"void","doc":"\n\n\t\tInitializes the module.\n\n\t\tThis changes #state to `ModuleState_Initialized`.\n\n\t\tRaises co.IllegalStateException if #state isn't `ModuleState_None`.\n\t ","parameters":[],"exceptions":["co.IllegalStateException"]},{"kind":"method","name":"integrate","returnType":"void","doc":"\n\n\t\tIntegrates the module with the system.\n\n\t\tThis changes #state to `ModuleState_Integrated`.\n\n\t\tRaises co.IllegalStateException if #state isn't `ModuleState_Initialized`.\n\t ","parameters":[],"exceptions":["co.IllegalStateException"]},{"kind":"method","name":"integratePresentation","returnType":"void","doc":"\n\n\t\tIntegrates the module's presentation into the system.\n\n\t\tThis changes #state to `ModuleState_PresentationIntegrated`.\n\n\t\tRaises co.IllegalStateException if #state isn't `ModuleState_Integrated`.\n\t ","parameters":[],"exceptions":["co.IllegalStateException"]}],"cpp":""},{"name":"co.IModuleManager","kind":"interface","doc":"\n\n\tFaçade to the module system, with methods to find and load modules.\n\n\tCoral features an _extensible module system_ based on three concepts:\n\n\t1. A **module** is an aggregate of **module parts** loaded from a\n\t\t_namespace_ in the Coral repository. See co.IModule.\n\t2. A **module part** is an _artifact_ loaded as part of a module. It could\n\t\tbe a library, a script, etc. See co.IModulePart.\n\t3. A **loader** is a service that recognizes and loads a certain kind of\n\t\t**module part**. See co.IModulePartLoader.\n\n\tA namespace has a _loadable module_ if at least one **loader** can load a\n\t**module part** from its location. Use #isLoadable to check this, #load to\n\treally load a module, and #findModule to find an already-loaded module.\n\n\tThe framework starts with just one loader for _dynamic libraries_.\n\tSee #loaders, #installLoader and #uninstallLoader.\n\n\tGet this service from co.ISystem's co.ISystem#modules.\n\n\t---\n\ttags: module-system\n ","base":"co.IService","members":[{"kind":"field","name":"compatibilityChecking","type":"bool","isReadOnly":false,"doc":"\n\n\t\tWhether module compatibility checking is enabled.\n\n\t\tThe default is true, which means a module should abort itself if it\n\t\tnotices any problem that could lead to crashes or data corruption.\n\t\tYou may want to disable these checks for testing purposes.\n\t "},{"kind":"field","name":"loaders","type":"co.IModulePartLoader[]","isReadOnly":true,"doc":"\n List of installed loaders."},{"kind":"field","name":"modules","type":"co.IModule[]","isReadOnly":true,"doc":"\n List of loaded modules."},{"kind":"method","name":"findModule","returnType":"co.IModule","doc":"\n\n\t\tReturns the module currently loaded at namespace `moduleName`.\n\t ","parameters":[{"name":"moduleName","type":"string","mode":"in"}],"exceptions":[]},{"kind":"method","name":"installLoader","returnType":"void","doc":"\n\n\t\tAdds a loader to #loaders.\n\n\t\tRaises co.IllegalArgumentException if `loader` is invalid.\n\t ","parameters":[{"name":"loader","type":"co.IModulePartLoader","mode":"in"}],"exceptions":[]},{"kind":"method","name":"isLoadable","returnType":"bool","doc":"\n\n\t\tReturns whether namespace `moduleName` contains a loadable module.\n\n\t\tWarning: a positive result does not guarantee that #load will succeed.\n\t ","parameters":[{"name":"moduleName","type":"string","mode":"in"}],"exceptions":[]},{"kind":"method","name":"load","returnType":"co.IModule","doc":"\n\n\t\tGets or loads the module at namespace `moduleName`.\n\n\t\tThis method calls all #loaders to gather a list of co.IModulePart's\n\t\tfrom `moduleName` and create a co.IModule. The module is integrated\n\t\tinto the system by means of events---which may load more modules,\n\t\tin a cascade effect.\n\n\t\tAny module that raises an exception during an event is aborted.\n\n\t\tRaises co.IllegalStateException if the system is inoperative.\n\t\tRaises co.ModuleLoadException if the module cannot be loaded.\n\t ","parameters":[{"name":"moduleName","type":"string","mode":"in"}],"exceptions":["co.ModuleLoadException","co.IllegalStateException"]},{"kind":"method","name":"uninstallLoader","returnType":"void","doc":"\n\n\t\tRemoves an installed loader.\n\n\t\tRaises co.IllegalArgumentException if `loader` isn't found in #loaders.\n\t ","parameters":[{"name":"loader","type":"co.IModulePartLoader","mode":"in"}],"exceptions":[]}],"cpp":""},{"name":"co.IModulePart","kind":"interface","doc":"\n\n\tRepresents an artifact loaded as part of a module.\n\n\tA module part represents an artifact---such as a library, script or data\n\tfile---that adds functionality to the system.\n\n\tThis interface plays a central role in program composition, since it\n\tultimately handles all system life-cycle events.\n\n\tSee co.IModule for an explanation of all module events.\n\n\t---\n\ttags: module-system\n ","base":"co.IService","members":[{"kind":"method","name":"disintegrate","returnType":"void","doc":"\n\n\t\tDisintegrates the module part from the system.\n\t ","parameters":[{"name":"module","type":"co.IModule","mode":"in"}],"exceptions":[]},{"kind":"method","name":"dispose","returnType":"void","doc":"\n\n\t\tDisposes the module part.\n\t ","parameters":[{"name":"module","type":"co.IModule","mode":"in"}],"exceptions":[]},{"kind":"method","name":"initialize","returnType":"void","doc":"\n\n\t\tInitializes the module part.\n\t ","parameters":[{"name":"module","type":"co.IModule","mode":"in"}],"exceptions":[]},{"kind":"method","name":"integrate","returnType":"void","doc":"\n\n\t\tIntegrates the module part with the system.\n\t ","parameters":[{"name":"module","type":"co.IModule","mode":"in"}],"exceptions":[]},{"kind":"method","name":"integratePresentation","returnType":"void","doc":"\n\n\t\tIntegrates the module part's presentation into the system.\n\t ","parameters":[{"name":"module","type":"co.IModule","mode":"in"}],"exceptions":[]}],"cpp":""},{"name":"co.IModulePartLoader","kind":"interface","doc":"\n\n\tLoads a certain kind of co.IModulePart from the repository.\n\n\t---\n\ttags: module-system\n ","base":"co.IService","members":[{"kind":"method","name":"canLoadModulePart","returnType":"bool","doc":"\n\n\t\tReturns whether a module part can be loaded from `moduleName`.\n\n\t\tThis checks if the repository contains a loadable module artifact in\n\t\tnamespace `moduleName`. For example, the default loader would check\n\t\tif a dynamic library file named `moduleName` exists in `moduleName`.\n\t ","parameters":[{"name":"moduleName","type":"string","mode":"in"}],"exceptions":[]},{"kind":"method","name":"loadModulePart","returnType":"co.IModulePart","doc":"\n\n\t\tLoads a module part from namespace `moduleName`.\n\n\t\tAny exception raised by this method will force the module's abortion.\n\t ","parameters":[{"name":"moduleName","type":"string","mode":"in"}],"exceptions":[]}],"cpp":""},{"name":"co.INamespace","kind":"interface","doc":"\n\n\tRepresents a namespace in the Coral repository.\n\n\tNamespaces are the _nodes_ in the hierarchy of the Coral repository.\n\tA namespace's #fullName stands for a unique (dot-separated) _tree path_\n\tin the repository. For example, `foo.bar` means _(root)_⇒`foo`⇒`bar`.\n\n\tA namespace contains #types, #childNamespaces, and possibly a reference\n\tto its corresponding #module (if one is loaded).\n\n\tThe unnamed _(root)_ namespace is available from co.ITypeManager.\n\n\t---\n\ttags: type-system\n ","base":"co.IService","members":[{"kind":"field","name":"childNamespaces","type":"co.INamespace[]","isReadOnly":true,"doc":"\n List of child namespaces."},{"kind":"field","name":"fullName","type":"string","isReadOnly":true,"doc":"\n Fully qualified name of the namespace. For example, \"foo.bar\"."},{"kind":"field","name":"module","type":"co.IModule","isReadOnly":true,"doc":"\n Module loaded in this namespace, or null if none was loaded."},{"kind":"field","name":"name","type":"string","isReadOnly":true,"doc":"\n Local name of the namespace within its parent. For example, \"bar\"."},{"kind":"field","name":"parentNamespace","type":"co.INamespace","isReadOnly":true,"doc":"\n Parent namespace, or null if this is the root."},{"kind":"field","name":"types","type":"co.IType[]","isReadOnly":true,"doc":"\n List of local types (i.e. defined in this namespace)."},{"kind":"method","name":"defineChildNamespace","returnType":"co.INamespace","doc":"\n\n\t\tCreates a child namespace with the given `name`.\n\n\t\tRaises co.IllegalNameException if `name` is not a valid identifier.\n\t\tRaises co.IllegalNameException if `name` clashes with something.\n\t ","parameters":[{"name":"name","type":"string","mode":"in"}],"exceptions":["co.IllegalNameException"]},{"kind":"method","name":"defineType","returnType":"co.ITypeBuilder","doc":"\n\n\t\tCreates a local type with the given `name` and `kind`.\n\n\t\tTo complete the type definition you must pass all required data to\n\t\tthe returned co.ITypeBuilder. Once you're done defining a graph of\n\t\tinterdependent types, use the system's co.ITypeManager#transaction\n\t\tto _commit_ the graph to the system.\n\n\t\tRaises co.IllegalNameException if `name` is not a valid identifier.\n\t\tRaises co.IllegalNameException if `name` clashes with something.\n\t\tRaises co.IllegalArgumentException if `kind` is invalid.\n\t ","parameters":[{"name":"name","type":"string","mode":"in"},{"name":"kind","type":"co.TypeKind","mode":"in"}],"exceptions":["co.IllegalNameException","co.IllegalArgumentException"]},{"kind":"method","name":"findChildNamespace","returnType":"co.INamespace","doc":"\n\n\t\tFinds a child namespace by name.\n\t\t\n\t\tReturns null if no namespace is found.\n\t ","parameters":[{"name":"name","type":"string","mode":"in"}],"exceptions":[]},{"kind":"method","name":"findType","returnType":"co.IType","doc":"\n\n\t\tFinds a local type by name.\n\n\t\tReturns null if no type is found.\n\t ","parameters":[{"name":"name","type":"string","mode":"in"}],"exceptions":[]}],"cpp":""},{"name":"co.INativeClass","kind":"interface","doc":"\n\n\tDescribes a native class type.\n\n\tA native class _imports_ a type from C++ to Coral as a _value type_ with\n\tfields and methods. It can efficiently represent small domain-specific\n\tobjects such as color, 3D vectors, 4x4 matrices, and so forth.\n\n\tEvery native class definition includes its own C++ type declaration---that\n\tis, a chunk of C++ code that defines a type with the same name and under\n\tthe same namespace as the native class. See the co.ICppBlock annotation.\n\n\tYou may choose to only _forward declare_ the C++ type in the native class.\n\tIn this case you must use the `co.Include` annotation (see co.IInclude)\n\tto specify which C++ header to include in order to use the native class.\n\n\t---\n\ttags: type-introspection\n ","base":"co.IClassType","members":[],"cpp":""},{"name":"co.IncludeAnnotation","kind":"component","doc":"\n\n\tProvides the `@co.Include` annotation for use with native classes.\n\n\t---\n\ttags: type-annotation\n ","members":[{"kind":"facet","name":"annotation","type":"co.IInclude","doc":"\n The annotation type."}]},{"name":"co.Interface","kind":"component","doc":"\n\n\tImplements co.IInterface.\n\t---\n\ttags: private type-introspection\n ","members":[{"kind":"facet","name":"type","type":"co.IInterface","doc":""}]},{"name":"co.IObject","kind":"interface","doc":"\n\n\tProvides object identity and reflection for every component instance.\n\n\tIn Coral terminology, an _object_ is an instance of a component.\n\tObjects are the underlying building blocks of an application. Although\n\tthe application _works_ in terms of services, it is ultimately _built_ in\n\tterms of objects. The decoupling of services and objects (or interfaces\n\tand components) promotes reuse and results in more adaptable architectures.\n\n\tEvery object exists to _provide services_ through its ports, and by design\n\t__all objects must provide__ co.IObject at the first port.\n\n\tAn object may also need to _use services_ from other objects, which poses\n\tthe question of _how it should obtain references to external services_.\n\tOur advice is that every (or most) service dependencies should be made\n\texplicit---to support dependency injection---through a _receptacle_,\n\twhich is a port that works like a field.\n\n\t_(Ports and fields are very similar, so both will merge in the future.)_\n\n\t---\n\ttags: component-model\n ","base":"co.IService","members":[{"kind":"field","name":"component","type":"co.IComponent","isReadOnly":true,"doc":"\n The component from which this object was created."},{"kind":"method","name":"getServiceAt","returnType":"co.IService","doc":"\n\n\t\tReturns the service provided-by or bound-to a `port` in this object.\n\n\t\tThe result can only be NULL if the port is a _receptacle_ (it would\n\t\tindicate that no service is bound to the port).\n\n\t\tRaises co.NoSuchPortException if the `port` is invalid.\n\t ","parameters":[{"name":"port","type":"co.IPort","mode":"in"}],"exceptions":["co.NoSuchPortException"]},{"kind":"method","name":"setServiceAt","returnType":"void","doc":"\n\n\t\tBinds a `service` to a `receptacle` in this object.\n\n\t\tRaises co.NoSuchPortException if `receptacle` is invalid.\n\t\tRaises co.IllegalCastException if `service` is invalid for the `receptacle`.\n\t\tRaises co.IllegalStateException if `receptacle` cannot be changed in the current object state.\n\t ","parameters":[{"name":"receptacle","type":"co.IPort","mode":"in"},{"name":"service","type":"co.IService","mode":"in"}],"exceptions":["co.NoSuchPortException","co.IllegalCastException","co.IllegalStateException"]}],"cpp":"\n\t/*\n\t\tReturns the first service of type `T` provided by this object;\n\t\tor NULL if there is no service of type `T`.\n\t */\n\ttemplate<typename T> inline T* findService()\n\t{\n\t\treturn static_cast<T*>( findServiceByType( this, typeOf<T>::get() ) );\n\t}\n\n\t/*\n\t\tReturns the first service of type T provided by this object.\n\t\tRaises co.NoSuchPortException if there is no service of type `T`.\n\t */\n\ttemplate<typename T> inline T* getService()\n\t{\n\t\treturn static_cast<T*>( getServiceByType( this, typeOf<T>::get() ) );\n\t}\n\n\t/*\n\t\tReturns the service at port `portName` in this object;\n\t\tor NULL if there's no port named `portName`.\n\t\t__Note__ that NULL is also a valid value for a receptacle.\n\t */\n\tinline IService* findService( const std::string& portName )\n\t{\n\t\treturn findServiceByName( this, portName );\n\t}\n\n\t/*\n\t\tReturns the service at port `portName` in this object;\n\t\tRaises co.NoSuchPortException if there's no port named `portName`.\n\t */\n\tinline IService* getService( const std::string& portName )\n\t{\n\t\treturn getServiceByName( this, portName );\n\t}\n\n\t// Binds a `service` to the receptacle named `receptacleName`.\n\tinline void setService( const std::string& receptacleName, IService* service )\n\t{\n\t\tsetServiceByName( this, receptacleName, service );\n\t}\n\t"},{"name":"co.IParameter","kind":"interface","doc":"\n\n\tDescribes a method parameter. See co.IMethod.\n\n\tFor every parameter, either #isIn or #isOut (or both) must be true.\n\n\t---\n\ttags: type-introspection\n ","base":"co.IService","members":[{"kind":"field","name":"isIn","type":"bool","isReadOnly":true,"doc":"\n Whether the parameter is used as input."},{"kind":"field","name":"isOut","type":"bool","isReadOnly":true,"doc":"\n Whether the parameter is used as output."},{"kind":"field","name":"name","type":"string","isReadOnly":true,"doc":"\n Parameter name."},{"kind":"field","name":"type","type":"co.IType","isReadOnly":true,"doc":"\n Parameter type."}],"cpp":""},{"name":"co.IPort","kind":"interface","doc":"\n\n\tDescribes a component port. See co.IComponent.\n\n\tA port can be either a _facet_ or a _receptacle_. A facet is a port\n\tthat _provides_ a service, while a receptacle is a port that _receives_\n\ta service (indicating a dependency).\n\n\t---\n\ttags: type-introspection\n ","base":"co.IMember","members":[{"kind":"field","name":"isFacet","type":"bool","isReadOnly":true,"doc":"\n Whether this port is a facet (true) or a receptacle (false)."},{"kind":"field","name":"type","type":"co.IInterface","isReadOnly":true,"doc":"\n Port interface---indicates the type of service provided or received."}],"cpp":""},{"name":"co.IRecordType","kind":"interface","doc":"\n\n\tInterface for types that have fields.\n\n\t---\n\ttags: type-introspection\n ","base":"co.ICompositeType","members":[{"kind":"field","name":"fields","type":"co.IField[]","isReadOnly":true,"doc":"\n List of member fields."}],"cpp":""},{"name":"co.IReflector","kind":"interface","doc":"\n\n\tHandles reflection operations for a Coral type.\n\n\tCoral handles reflection operations for a #type through a _reflector_.\n\tReflectors are automatically generated by the Coral compiler, so you\n\tdon't have to write one unless you're working on something magic.\n\n\tAll reflectors share this uniform interface, but only a subset of the\n\tmethods are expected to be supported for a certain #type (depending on its\n\tkind). Please take notice of each method's exception specifications.\n\n\tMethods that receive values of type `any`---namely #getField, #setField\n\tand #invoke---can often handle type conversions. For example, #setField\n\tcan receive a `double` and store it into a `string` field.\n\tThe conversions are handled transparently by the `any` type---check\n\tits documentation for a list of supported conversions.\n\n\tNote that some lower-level methods are only available from C++.\n\t---\n\ttags: type-system\n ","base":"co.IService","members":[{"kind":"field","name":"size","type":"uint32","isReadOnly":true,"doc":"\n Number of bytes occupied by instances of this type."},{"kind":"field","name":"type","type":"co.IType","isReadOnly":true,"doc":"\n The type we are providing reflection for."},{"kind":"method","name":"getField","returnType":"void","doc":"\n\n\t\tGets the value of a `field` in `instance` and puts it into `var`.\n\n\t\tRaises co.NotSupportedException if #type is not a co.IRecordType.\n\t\tRaises co.IllegalArgumentException if `instance` is not of #type.\n\t\tRaises co.IllegalArgumentException if the `field` is not from #type.\n\t\tRaises co.IllegalStateException if `var` is not an output variable.\n\t\tRaises co.IllegalCastException if `var` cannot store the field value.\n\t ","parameters":[{"name":"instance","type":"any","mode":"in"},{"name":"field","type":"co.IField","mode":"in"},{"name":"var","type":"any","mode":"in"}],"exceptions":["co.NotSupportedException","co.IllegalArgumentException","co.IllegalStateException","co.IllegalCastException"]},{"kind":"method","name":"invoke","returnType":"void","doc":"\n\n\t\tInvokes a `method` from `instance`.\n\n\t\tArguments are passed in `args` in direct order.\n\t\tOutput parameters must be honored (by passing _out_ variables).\n\t\tExcess arguments are currently ignored.\n\n\t\tIf the callee raises an exception, it will propagate unchanged;\n\t\totherwise, whatever is returned is put into `retVal`.\n\n\t\tRaises co.NotSupportedException if #type is not a co.IClassType.\n\t\tRaises co.IllegalArgumentException if `instance` is not of #type.\n\t\tRaises co.IllegalArgumentException if the `method` is not from #type.\n\t\tRaises co.MissingInputException if `args` contains fewer arguments than the method expects.\n\t\tRaises co.IllegalStateException if an argument should be an _out_ variable but isn't.\n\t\tRaises co.IllegalCastException if an argument cannot be converted to the parameter type.\n\t ","parameters":[{"name":"instance","type":"any","mode":"in"},{"name":"method","type":"co.IMethod","mode":"in"},{"name":"args","type":"any[]","mode":"in"},{"name":"retVal","type":"any","mode":"in"}],"exceptions":["co.NotSupportedException","co.IllegalArgumentException","co.MissingInputException","co.IllegalStateException","co.IllegalCastException"]},{"kind":"method","name":"newDynamicProxy","returnType":"co.IService","doc":"\n\n\t\tCreates a _dynamic proxy_ (of this #type) to the specified `provider`.\n\n\t\tA _dynamic proxy_ is a service that uses reflection to delegate all\n\t\tcalls to a co.IDynamicServiceProvider. The proxy will always call\n\t\tco.IDynamicServiceProvider#dynamicRegisterService on the `provider`\n\t\tfrom within its constructor.\n\n\t\tRaises co.NotSupportedException if #type is not a co.IInterface.\n\t\tRaises co.IllegalArgumentException if `provider` is invalid (null).\n\t ","parameters":[{"name":"provider","type":"co.IDynamicServiceProvider","mode":"in"}],"exceptions":["co.NotSupportedException","co.IllegalArgumentException"]},{"kind":"method","name":"newInstance","returnType":"co.IObject","doc":"\n\n\t\tInstantiates a component.\n\t\t\n\t\tRaises co.NotSupportedException if #type is not a co.IComponent.\n\t ","parameters":[],"exceptions":["co.NotSupportedException"]},{"kind":"method","name":"raise","returnType":"void","doc":"\n\n\t\tRaises an exception (of this #type) with the given `message`.\n\n\t\tRaises co.NotSupportedException if #type is not an exception.\n\t ","parameters":[{"name":"message","type":"string","mode":"in"}],"exceptions":["co.NotSupportedException"]},{"kind":"method","name":"setField","returnType":"void","doc":"\n\n\t\tSets the value of a `field` in `instance` to `value`.\n\n\t\tRaises co.NotSupportedException if #type is not a co.IRecordType.\n\t\tRaises co.IllegalArgumentException if `instance` is not of #type.\n\t\tRaises co.IllegalArgumentException if the `field` is not from #type.\n\t\tRaises co.IllegalArgumentException if the `field` is _read-only_.\n\t\tRaises co.IllegalCastException if the field cannot store the `value`.\n\t ","parameters":[{"name":"instance","type":"any","mode":"in"},{"name":"field","type":"co.IField","mode":"in"},{"name":"value","type":"any","mode":"in"}],"exceptions":["co.NotSupportedException","co.IllegalArgumentException","co.IllegalCastException"]}],"cpp":"\n\t/*\n\t\tConstructs an array of values in memory starting at `ptr`.\n\t\tThe memory area should be at least `numValues * size` bytes long.\n\t\tRaises co.NotSupportedException if #type cannot be cast to a value.\n\t */\n\tvirtual void createValues( void* ptr, size_t numValues ) = 0;\n\n\t/*\n\t\tCopies the array of values at `fromPtr` to `toPtr`.\n\t\tBoth arrays must contain `numValues` properly constructed values.\n\t\tEach copy is done using the value's assignment operator.\n\t\tRaises co.NotSupportedException if #type cannot be cast to a value.\n\t */\n\tvirtual void copyValues( const void* fromPtr, void* toPtr, size_t numValues ) = 0;\n\n\t/*\n\t\tDestructs an array of `numValues` values starting at `ptr`.\n\t\tAll values must have been constructed with createValues().\n\t\tRaises co.NotSupportedException if #type cannot be cast to a value.\n\t */\n\tvirtual void destroyValues( void* ptr, size_t numValues ) = 0;\n\n\t/*\n\t\tReturns true if and only if a0 == b0, a1 == b1, ... aN == bN.\n\t\tRaises co.NotSupportedException if #type cannot be cast to a value.\n\t */\n\tvirtual bool compareValues( const void* a, const void* b, size_t numValues ) = 0;\n\t"},{"name":"co.IService","kind":"interface","doc":"\n\n\tBase of all interfaces. Represents a service provided by an object.\n\n\tCoral follows a service-oriented architecture (SOA), in which services\n\tare the basic unit of abstraction.\n\n\tA _service_ is a self-contained unit of functionality. Every service is\n\tprovided _by_ an object (the #provider) _through_ an #interface. This is\n\ta design pattern closely related to component-based design. Service\n\torientation is popular in distributed systems, but we think it also makes\n\tsense for an in-process component model such as Coral's.\n\n\t---\n\ttags: component-model\n ","base":null,"members":[{"kind":"field","name":"facet","type":"co.IPort","isReadOnly":true,"doc":"\n The port (within the #provider) where this service is provided."},{"kind":"field","name":"interface","type":"co.IInterface","isReadOnly":true,"doc":"\n The interface through which this service is provided."},{"kind":"field","name":"provider","type":"co.IObject","isReadOnly":true,"doc":"\n The object that provides this service."},{"kind":"method","name":"serviceRelease","returnType":"void","doc":"\n\n\t\tDecrements the service's reference count.\n\n\t\t**Never call this method directly unless you know what you're doing.**\n\n\t\tThis will decrement the #provider's reference count.\n\t ","parameters":[],"exceptions":[]},{"kind":"method","name":"serviceRetain","returnType":"void","doc":"\n\n\t\tIncrements the service's reference count.\n\n\t\t**Never call this method directly unless you know what you're doing.**\n\n\t\tThis will increment the #provider's reference count.\n\t ","parameters":[],"exceptions":[]}],"cpp":""},{"name":"co.IServiceManager","kind":"interface","doc":"\n\n\tA central database where services are _published_ and _queried_.\n\n\tServices are always queried by type---an instance of co.IInterface---so\n\tfor example, you can find a car by looking for a service of type `ICar`,\n\ta boat by looking for `IBoat`, or either by looking for `IVehicle`.\n\n\tThe database supports three types of queries:\n\n\t1. Global Query _(S)_\n\t: Returns the service of type `S` published for global use---the Coral\n\tanalogue of a _singleton_. For example, queries with `S`=`ICar` would\n\talways return the same general-purpose car instance.\n\tSee #addService and #getService.\n\n\t2. Type-specialized Query _(S, T)_\n\t: Returns a service of type `S` specialized for the type `T`.\n\tFor example, you may query a vehicle _specialized by medium_ so that with\n\t`S`=`IVehicle`, `T`=`IWater` you'd get a boat, and with `S`=`IVehicle`,\n\t`T`=`IRoad` you'd get a car. When an exact result is not available, the\n\tquery goes for the next best result by querying the ancestors of `T`,\n\tuntil it finally falls back to a global query.\n\tSee #addServiceForType and #getServiceForType.\n\n\t3. Instance-specialized Query _(S, I)_\n\t: Returns a service of type `S` specialized for an instance `I`. First we\n\tcheck if `I`'s co.IObject also provides a service of type `S`---if so, it\n\tis returned; otherwise, we fall back to query 2 with `T`=`I.interface`.\n\tBuilding on the previous example, although a car is suitable for most\n\troads, on a few rough ones you may want to switch to an off-road vehicle.\n\tThat is, you want the query to return a specialized vehicle for a certain\n\troad `I`. In order to achieve this, you add a port of type `S` (providing\n\tthe vehicle) to `I`'s object. See #getServiceForInstance.\n\n\tNotice that query 3 falls back to query 2, and query 2 falls back to\n\tquery 1. As a result, once you publish a global service of type `S`,\n\tall specialized queries for `S` are guaranteed to succeed.\n\n\t**Database keys are unique**---publishing a service will replace any\n\tprevious record with the same key.\n\n\t**Lazy instantiation**---instead of adding a service, you may specify the\n\t_name of a component_ that provides the service, and it won't be created\n\tuntil the service is first queried.\n\tSee #addServiceProvider and #addServiceProviderForType.\n\n\tGet this service from co.ISystem's co.ISystem#services.\n\n\t---\n\ttags: component-model\n ","base":"co.IService","members":[{"kind":"field","name":"isLazy","type":"bool","isReadOnly":false,"doc":"\n\n\t\tWhether lazy instantiation is enabled. Default is true.\n\n\t\tIf false, components will be instantiated when added, instead of\n\t\twhen queried.\n\t "},{"kind":"method","name":"addService","returnType":"void","doc":"\n\n\t\tPublishes a `global` provider of `serviceType`.\n\n\t\tRaises co.IllegalArgumentException if any argument is null.\n\t\tRaises co.IllegalCastException if `service` is not of `serviceType`.\n\t ","parameters":[{"name":"serviceType","type":"co.IInterface","mode":"in"},{"name":"global","type":"co.IService","mode":"in"}],"exceptions":["co.IllegalArgumentException","co.IllegalCastException"]},{"kind":"method","name":"addServiceForType","returnType":"void","doc":"\n\n\t\tPublishes a `specialized` provider of `serviceType` for `type`.\n\n\t\tRaises co.IllegalArgumentException if any argument is null.\n\t\tRaises co.IllegalCastException if `service` is not of `serviceType`.\n\t ","parameters":[{"name":"serviceType","type":"co.IInterface","mode":"in"},{"name":"type","type":"co.IInterface","mode":"in"},{"name":"specialized","type":"co.IService","mode":"in"}],"exceptions":["co.IllegalArgumentException","co.IllegalCastException"]},{"kind":"method","name":"addServiceProvider","returnType":"void","doc":"\n\n\t\tPublishes a global provider of `serviceType` (with lazy instantiation).\n\n\t\tThe service is obtained from a new instance of `componentName`, by\n\t\tscanning the object for a service of type `serviceType`. If an error\n\t\toccurs, we drop the service and raise co.MissingServiceException.\n\n\t\tRaises co.IllegalArgumentException if any argument is invalid.\n\t\tRaises co.NoSuchPortException if the component does not provide `serviceType`.\n\t\tRaises co.MissingServiceException if #isLazy is false and we cannot obtain the service.\n\t ","parameters":[{"name":"serviceType","type":"co.IInterface","mode":"in"},{"name":"componentName","type":"string","mode":"in"}],"exceptions":["co.IllegalArgumentException","co.NoSuchPortException","co.MissingServiceException"]},{"kind":"method","name":"addServiceProviderForType","returnType":"void","doc":"\n\n\t\tPublishes a specialized provider of `serviceType` for `type` (with\n\t\tlazy instantiation).\n\n\t\tThe service is obtained from a new instance of `componentName`, by\n\t\tscanning the object for a service of type `serviceType`. If an error\n\t\toccurs, we drop the service and raise co.MissingServiceException.\n\n\t\tRaises co.IllegalArgumentException if any argument is invalid.\n\t\tRaises co.NoSuchPortException if the component does not provide `serviceType`.\n\t\tRaises co.MissingServiceException if #isLazy is false and we cannot obtain the service.\n\t ","parameters":[{"name":"serviceType","type":"co.IInterface","mode":"in"},{"name":"type","type":"co.IInterface","mode":"in"},{"name":"componentName","type":"string","mode":"in"}],"exceptions":["co.IllegalArgumentException","co.NoSuchPortException","co.MissingServiceException"]},{"kind":"method","name":"getService","returnType":"co.IService","doc":"\n\n\t\tReturns the global service of type `serviceType`.\n\n\t\tRaises co.IllegalArgumentException if `serviceType` is null.\n\t\tRaises co.MissingServiceException if no result is found.\n\t ","parameters":[{"name":"serviceType","type":"co.IInterface","mode":"in"}],"exceptions":["co.IllegalArgumentException","co.MissingServiceException"]},{"kind":"method","name":"getServiceForInstance","returnType":"co.IService","doc":"\n\n\t\tReturns a service of type `serviceType` specialized for `instance`.\n\n\t\tRaises co.IllegalArgumentException if any argument is null.\n\t\tRaises co.MissingServiceException if no result is found.\n\t ","parameters":[{"name":"serviceType","type":"co.IInterface","mode":"in"},{"name":"instance","type":"co.IService","mode":"in"}],"exceptions":["co.IllegalArgumentException","co.MissingServiceException"]},{"kind":"method","name":"getServiceForType","returnType":"co.IService","doc":"\n\n\t\tReturns a service of type `serviceType` specialized for `type`.\n\n\t\tRaises co.IllegalArgumentException if any argument is null.\n\t\tRaises co.MissingServiceException if no result is found.\n\t ","parameters":[{"name":"serviceType","type":"co.IInterface","mode":"in"},{"name":"clientType","type":"co.IInterface","mode":"in"}],"exceptions":["co.IllegalArgumentException","co.MissingServiceException"]},{"kind":"method","name":"removeService","returnType":"void","doc":"\n\n\t\tRemoves the service of type `serviceType` published for global use.\n\n\t\tRaises co.MissingServiceException if no such service is found.\n\t ","parameters":[{"name":"serviceType","type":"co.IInterface","mode":"in"}],"exceptions":["co.MissingServiceException"]},{"kind":"method","name":"removeServiceForType","returnType":"void","doc":"\n\n\t\tRemoves the service of type `serviceType` published for `type`.\n\n\t\tRaises co.MissingServiceException if no such service is found.\n\t ","parameters":[{"name":"serviceType","type":"co.IInterface","mode":"in"},{"name":"clientType","type":"co.IInterface","mode":"in"}],"exceptions":["co.MissingServiceException"]}],"cpp":""},{"name":"co.IStruct","kind":"interface","doc":"\n\n\tDescribes a struct type.\n\n\tA struct is a set of named fields of various types. Field declaration\n\torder is irrelevant, since Coral automatically re-arranges struct fields\n\taccording to size in C++.\n\n\t---\n\ttags: type-introspection\n ","base":"co.IRecordType","members":[],"cpp":""},{"name":"co.ISystem","kind":"interface","doc":"\n\n\tFaçade to the whole system. Controls the system's life cycle.\n\n\tThe Coral _system_ coordinates the dynamic set of #modules, #types\n\tand #services that compose a program at runtime.\n\n\tA _program_ in Coral is a runtime composition of modules, types and\n\tservices subject to the system's life cycle.\n\n\tThe system's _life cycle_ starts with a nil #state, as shown in the\n\tdiagram below. From nil, the _set-up_ process sets the system up and\n\trunning by initializing and integrating modules. When the program is over,\n\tthe _teardown_ process resets the system to nil by disintegrating and\n\tdisposing all modules. The grayed boxes in the center correspond to the\n\t_module events_ that are triggered during a set-up/teardown cycle.\n\t![](system-life-cycle.svg 'The system's life cycle'){:.centerfig}\n\n\tThe co.ISystem service is Coral's only _singleton_. See the documentation\n\ton [how to obtain it in C++](/reference/languages/cpp#getSystem)\n\tor [another language](/reference/languages).\n\n\t---\n\ttags: system\n ","base":"co.IService","members":[{"kind":"field","name":"modules","type":"co.IModuleManager","isReadOnly":true,"doc":"\n Façade to the module system, with methods to find and load modules."},{"kind":"field","name":"services","type":"co.IServiceManager","isReadOnly":true,"doc":"\n A global database where services are published and queried."},{"kind":"field","name":"state","type":"co.SystemState","isReadOnly":true,"doc":"\n The system's current life-cycle state. See co.SystemState."},{"kind":"field","name":"types","type":"co.ITypeManager","isReadOnly":true,"doc":"\n Façade to the type system, with methods to find, load and create types."},{"kind":"method","name":"setupBase","returnType":"void","doc":"\n\n\t\tLoads all `requiredModules` (if any) and integrates the system.\n\n\t\tMust be called when the system's #state is `SystemState_None`.\n\t\tThis method changes #state to `SystemState_Integrated` on success,\n\t\tor back to `SystemState_None` on exceptions.\n\n\t\tRaises co.IllegalStateException if #state isn't `SystemState_None`.\n\t\tRaises co.ModuleLoadException if loading one of the `requiredModules` fails.\n\t ","parameters":[{"name":"requiredModules","type":"string[]","mode":"in"}],"exceptions":["co.IllegalStateException","co.ModuleLoadException"]},{"kind":"method","name":"setupPresentation","returnType":"void","doc":"\n\n\t\tIntegrates the presentation layer and sets the system running.\n\n\t\tMust be called after #setupBase.\n\t\tThe system's #state changes to `SystemState_Running` on success.\n\n\t\tRaises co.IllegalStateException if #state isn't `SystemState_Integrated`.\n\t ","parameters":[],"exceptions":["co.IllegalStateException"]},{"kind":"method","name":"tearDown","returnType":"void","doc":"\n\n\t\tDisintegrates and disposes all modules.\n\n\t\tMust be called while the system is running.\n\t\tThis resets the system's #state to `SystemState_None`.\n\n\t\tRaises co.IllegalStateException if #state isn't `SystemState_Running`.\n\t ","parameters":[],"exceptions":["co.IllegalStateException"]}],"cpp":"\n\t\t// Sets the system up and running without loading any modules.\n\t\tinline void setup() { setup( Slice<std::string>() ); }\n\n\t\t// Sets the system up and running with the specified modules.\n\t\tinline void setup( Slice<std::string> requiredModules )\n\t\t{\n\t\t\tsetupBase( requiredModules );\n\t\t\tsetupPresentation();\n\t\t}\n\t"},{"name":"co.IType","kind":"interface","doc":"\n\n\tRepresents a Coral type. Base interface for type descriptors.\n\n\tTypes can be identified either by a #name within a #namespace, or uniquely\n\tby #fullName. Every type has a #kind that determines its actual type and\n\tdescriptor interface (i.e. subtype of co.IType).\n\n\t---\n\ttags: type-system\n ","base":"co.IAnnotated","members":[{"kind":"field","name":"binarySignature","type":"co.Uuid","isReadOnly":true,"doc":"\n\n\t\tFingerprint of the type's binary interface.\n\n\t\tConsiders all data that could affect the _binary interface_ of\n\t\ta type---i.e. things that break C++ ABI compatibility.\n\t "},{"kind":"field","name":"currentReflector","type":"co.IReflector","isReadOnly":true,"doc":"\n\n\t\tThe type's reflector, or null if a reflector hasn't been set yet.\n\n\t\tTo guarantee you'll obtain a reflector, get #reflector instead.\n\t "},{"kind":"field","name":"fullName","type":"string","isReadOnly":true,"doc":"\n Fully qualified name of the type. For example, \"nspc.SomeType\"."},{"kind":"field","name":"fullSignature","type":"co.Uuid","isReadOnly":true,"doc":"\n\n\t\tFingerprint of all type data (except annotations).\n\n\t\tConsiders all data that could affect the _source code_ of a type.\n\t "},{"kind":"field","name":"kind","type":"co.TypeKind","isReadOnly":true,"doc":"\n What kind of type is this type."},{"kind":"field","name":"name","type":"string","isReadOnly":true,"doc":"\n Local name of the type (within its namespace). For example, \"SomeType\"."},{"kind":"field","name":"namespace","type":"co.INamespace","isReadOnly":true,"doc":"\n Namespace where the type is defined."},{"kind":"field","name":"reflector","type":"co.IReflector","isReadOnly":false,"doc":"\n\n\t\tThe type's reflector. Getting this field may raise an exception.\n\n\t\tIf the reflector is null, the getter will attempt to load the type's\n\t\tmodule in order to get a reflector. If it's still null then, the\n\t\tgetter will raise an exception. The setter is plain and safe, however.\n\t "},{"kind":"method","name":"isA","returnType":"bool","doc":"\n\n\t\tReturns whether this type descends from the given `super` type.\n\n\t\tAlso returns true if this type is equal to `super`.\n\t ","parameters":[{"name":"super","type":"co.IType","mode":"in"}],"exceptions":[]}],"cpp":""},{"name":"co.ITypeBuilder","kind":"interface","doc":"\n\n\tAssists in the definition of a new Coral type.\n\n\tThe workflow for defining a new type is as follows:\n\n\t1. Create a type builder by calling co.INamespace#defineType on\n\ta co.INamespace.\n\t2. Pass data to the type builder via the _define_ methods below, as\n\tappropriate for the kind of type you're defining.\n\t3. Repeat 1 and 2 as needed to define a graph of types, then use the\n\tglobal co.ITypeManager#transaction to add the graph to the system.\n\n\t---\n\ttags: type-creation\n ","base":"co.IService","members":[{"kind":"field","name":"kind","type":"co.TypeKind","isReadOnly":true,"doc":"\n Kind of type being defined."},{"kind":"field","name":"namespace","type":"co.INamespace","isReadOnly":true,"doc":"\n Namespace where the type is being defined."},{"kind":"field","name":"typeName","type":"string","isReadOnly":true,"doc":"\n Local name of the type being defined."},{"kind":"method","name":"createType","returnType":"co.IType","doc":"\n\n\t\tCreates and returns the type. *You don't have to call this method.*\n\n\t\tThis method is automatically called when you co.ITypeTransaction#commit\n\t\ta type transaction.\n\n\t\tRaises co.MissingInputException if the type is missing required data.\n\t ","parameters":[],"exceptions":["co.MissingInputException"]},{"kind":"method","name":"defineBaseType","returnType":"void","doc":"\n\n\t\tMakes the type inherit from `baseType`.\n\n\t\tRaises co.NotSupportedException if the type doesn't support inheritance.\n\t\tRaises co.NotSupportedException if the type has already been created.\n\t\tRaises co.NotSupportedException if a base type was already defined.\n\t\tRaises co.IllegalArgumentException if `baseType` is invalid.\n\t ","parameters":[{"name":"baseType","type":"co.IType","mode":"in"}],"exceptions":["co.NotSupportedException","co.IllegalArgumentException"]},{"kind":"method","name":"defineField","returnType":"void","doc":"\n\n\t\tAdds a field to a record type (a struct, interface or native class).\n\n\t\tRaises co.NotSupportedException if the type is not a record type.\n\t\tRaises co.NotSupportedException if the type has already been created.\n\t\tRaises co.IllegalNameException if `name` is invalid.\n\t\tRaises co.IllegalArgumentException if `type` is invalid.\n\t\tRaises co.IllegalArgumentException if `isReadOnly` is true and #kind is TK_STRUCT.\n\t ","parameters":[{"name":"name","type":"string","mode":"in"},{"name":"type","type":"co.IType","mode":"in"},{"name":"isReadOnly","type":"bool","mode":"in"}],"exceptions":["co.NotSupportedException","co.IllegalNameException","co.IllegalArgumentException"]},{"kind":"method","name":"defineIdentifier","returnType":"void","doc":"\n\n\t\tAdds an identifier to an enum.\n\n\t\tRaises co.NotSupportedException if the type is not an enum.\n\t\tRaises co.NotSupportedException if the type has already been created.\n\t\tRaises co.IllegalNameException if `name` is invalid.\n\t ","parameters":[{"name":"name","type":"string","mode":"in"}],"exceptions":["co.NotSupportedException","co.IllegalNameException"]},{"kind":"method","name":"defineMethod","returnType":"co.IMethodBuilder","doc":"\n\n\t\tAdds a method to a class type (an interface or native class).\n\n\t\tYou must use the returned co.IMethodBuilder to complete the definition.\n\n\t\tRaises co.NotSupportedException if the type is not a class type.\n\t\tRaises co.NotSupportedException if the type has already been created.\n\t\tRaises co.IllegalNameException if `name` is invalid.\n\t ","parameters":[{"name":"name","type":"string","mode":"in"}],"exceptions":["co.NotSupportedException","co.IllegalNameException"]},{"kind":"method","name":"definePort","returnType":"void","doc":"\n\n\t\tAdds a port to a component.\n\n\t\tRaises co.NotSupportedException if the type is not a component.\n\t\tRaises co.NotSupportedException if the type has already been created.\n\t\tRaises co.IllegalNameException if `name` is invalid.\n\t\tRaises co.IllegalArgumentException if `itf` is invalid.\n\t ","parameters":[{"name":"name","type":"string","mode":"in"},{"name":"itf","type":"co.IInterface","mode":"in"},{"name":"isFacet","type":"bool","mode":"in"}],"exceptions":["co.NotSupportedException","co.IllegalNameException","co.IllegalArgumentException"]}],"cpp":""},{"name":"co.ITypeManager","kind":"interface","doc":"\n\n\tFaçade to the type system, with methods to find and create types.\n\n\tThe entire hierarchy of namespaces---with types and modules---can be\n\ttraversed from the #rootNS namespace. For example, to reach the `foo.bar`\n\tnamespace you'd traverse _(root)_⇒`foo`⇒`bar`. However, it's better to use\n\teither #findNamespace or #getNamespace for random access to a namespace.\n\n\tThis façade also provides random access to types. Use #getType to load a\n\ttype by full name, or #findType to get an existing type (without loading).\n\tIn order to get an array, simply append \"[]\" to the type name.\n\n\tGet this service from co.ISystem's co.ISystem#types.\n\n\t---\n\ttags: type-system\n ","base":"co.IService","members":[{"kind":"field","name":"rootNS","type":"co.INamespace","isReadOnly":true,"doc":"\n\n\t\tThe root (or global) namespace. Corresponds to the repository root.\n\n\t\tProvides hierarchical access to all types and modules.\n\t "},{"kind":"field","name":"transaction","type":"co.ITypeTransaction","isReadOnly":true,"doc":"\n\n\t\tTransaction that must be used in order to add types to the system.\n\n\t\tNew types are automatically added to this transaction and can only\n\t\tbe removed by a successful commit or rollback.\n\t "},{"kind":"method","name":"findNamespace","returnType":"co.INamespace","doc":"\n\n \t\tFinds an existing namespace by full name.\n\n \t\tReturns null if the namespace has not been created yet.\n \t ","parameters":[{"name":"fullName","type":"string","mode":"in"}],"exceptions":[]},{"kind":"method","name":"findType","returnType":"co.IType","doc":"\n\n\t\tFinds an existing type by full name.\n\n\t\tReturns null if the type doesn't exist or has not been loaded yet.\n\t ","parameters":[{"name":"fullName","type":"string","mode":"in"}],"exceptions":[]},{"kind":"method","name":"getArrayOf","returnType":"co.IArray","doc":"\n\n\t\tGets or creates an array of the given `elementType`.\n\n\t\tRaises co.IllegalArgumentException if `elementType` is an illegal array type.\n\t ","parameters":[{"name":"elementType","type":"co.IType","mode":"in"}],"exceptions":["co.IllegalArgumentException"]},{"kind":"method","name":"getNamespace","returnType":"co.INamespace","doc":"\n\n \t\tGets or creates a namespace by full name.\n\n \t\tRaises co.IllegalNameException if `fullName` is invalid.\n \t ","parameters":[{"name":"fullName","type":"string","mode":"in"}],"exceptions":[]},{"kind":"method","name":"getType","returnType":"co.IType","doc":"\n\n\t\tGets or loads a type by full name.\n\n\t\tThis method will get or create an array if `fullName` ends with \"[]\".\n\n\t\tRaises co.IllegalArgumentException if `fullName` is empty or an illegal array type.\n\t\tRaises co.TypeLoadException if an error occurs while loading the type.\n\t ","parameters":[{"name":"fullName","type":"string","mode":"in"}],"exceptions":["co.IllegalArgumentException","co.TypeLoadException"]},{"kind":"method","name":"loadType","returnType":"co.IType","doc":"\n\n\t\tGets or loads a type by full name, without raising exceptions.\n\n\t\tAs an alternative to #getType, instead of raising an exception in case\n\t\tof type load errors, this method will fill `errorStack` with details\n\t\t(from the outermost to the innermost error) and return null.\n\n\t\tThis method **does not create arrays**, but can get existing arrays.\n\t ","parameters":[{"name":"typeName","type":"string","mode":"in"},{"name":"errorStack","type":"co.CSLError[]","mode":"out"}],"exceptions":[]}],"cpp":""},{"name":"co.ITypeTransaction","kind":"interface","doc":"\n\n\tAtomically validates and adds a set of types to the system.\n\n\tThe transaction validates the integrity of a set of interdependent types\n\tas they are added to the system. If the validation fails, it removes all\n\ttypes in the transaction from the system.\n\n\t---\n\ttags: type-creation\n ","base":"co.IService","members":[{"kind":"field","name":"typeBuilders","type":"co.ITypeBuilder[]","isReadOnly":true,"doc":"\n List of type builders in the transaction."},{"kind":"method","name":"commit","returnType":"void","doc":"\n\n\t\tValidates and commits all types in the transaction.\n\n\t\tThis method validates all type builders in the transaction, checking\n\t\tfor missing data and semantic errors. If the validation fails, an\n\t\texception is raised and you _must_ call #rollback.\n\n\t\tRaises co.MissingInputException if a type is missing required data.\n\t\tRaises co.IllegalNameException if a type contains clashing members.\n\t\tRaises co.IllegalStateException if an inheritance cycle is detected.\n\t\tRaises co.NotSupportedException if the transaction is empty or dirty.\n\t ","parameters":[],"exceptions":["co.MissingInputException","co.IllegalNameException","co.IllegalStateException","co.NotSupportedException"]},{"kind":"method","name":"rollback","returnType":"void","doc":"\n\n\t\tRemoves references to the types in the transaction.\n\n\t\tThe types will die with their builders.\n\t ","parameters":[],"exceptions":[]}],"cpp":""},{"name":"co.MemberKind","kind":"enum","doc":"\n\n\tEnumeration of member kinds. See co.IMember.\n\n\t---\n\ttags: type-introspection\n ","identifiers":[{"id":"MK_FIELD","doc":" Field."},{"id":"MK_METHOD","doc":" Method."},{"id":"MK_PORT","doc":" Component port."}]},{"name":"co.Method","kind":"component","doc":"\n\n\tImplements co.IMethod.\n\t---\n\ttags: private type-introspection\n ","members":[{"kind":"facet","name":"methodInfo","type":"co.IMethod","doc":""}]},{"name":"co.MethodBuilder","kind":"component","doc":"\n\n\tImplements co.IMethodBuilder.\n\t---\n\ttags: private type-creation\n ","members":[{"kind":"facet","name":"methodBuilder","type":"co.IMethodBuilder","doc":""}]},{"name":"co.MissingInputException","kind":"exception","doc":"\n\n\tRaised when required input is missing.\n\t---\n\ttags: exception\n "},{"name":"co.MissingServiceException","kind":"exception","doc":"\n\n\tRaised when a required service is not available.\n\t---\n\ttags: exception\n "},{"name":"co.Module","kind":"component","doc":"\n\n\tImplements co.IModule.\n\t---\n\ttags: private module-system\n ","members":[{"kind":"facet","name":"module","type":"co.IModule","doc":""}]},{"name":"co.ModuleLoadException","kind":"exception","doc":"\n\n\tRaised when an error occurs while loading a module.\n\t---\n\ttags: exception\n "},{"name":"co.ModuleManager","kind":"component","doc":"\n\n\tImplements co.IModuleManager.\n\t---\n\ttags: private module-system\n ","members":[{"kind":"facet","name":"moduleManager","type":"co.IModuleManager","doc":""}]},{"name":"co.ModulePartLoader","kind":"component","doc":"\n\n\tDefault implementation of co.IModulePartLoader.\n\tLoads DLLs built from code generated by the Coral Compiler.\n\t---\n\ttags: private module-system\n ","members":[{"kind":"facet","name":"loader","type":"co.IModulePartLoader","doc":""}]},{"name":"co.ModuleState","kind":"enum","doc":"\n\n\tEnumeration of states in a module’s life cycle.\n\n\tSee co.IModule for an explanation of all module events.\n\n\t---\n\ttags: module-system\n ","identifiers":[{"id":"ModuleState_None","doc":""},{"id":"ModuleState_Initialized","doc":""},{"id":"ModuleState_Integrated","doc":""},{"id":"ModuleState_PresentationIntegrated","doc":""},{"id":"ModuleState_Disintegrated","doc":""},{"id":"ModuleState_Disposed","doc":""},{"id":"ModuleState_Aborted","doc":""}]},{"name":"co.Namespace","kind":"component","doc":"\n\n\tImplements co.INamespace.\n\t---\n\ttags: private type-introspection\n ","members":[{"kind":"facet","name":"namespace","type":"co.INamespace","doc":""}]},{"name":"co.NativeClass","kind":"component","doc":"\n\n\tImplements co.INativeClass.\n\t---\n\ttags: private type-introspection\n ","members":[{"kind":"facet","name":"type","type":"co.INativeClass","doc":""}]},{"name":"co.NoSuchPortException","kind":"exception","doc":"\n\n\tRaised when a requested port is not available.\n\t---\n\ttags: exception\n "},{"name":"co.NotSupportedException","kind":"exception","doc":"\n\n\tRaised when an operation is not supported.\n\t---\n\ttags: exception\n "},{"name":"co.Parameter","kind":"component","doc":"\n\n\tImplements co.IParameter.\n\t---\n\ttags: private type-introspection\n ","members":[{"kind":"facet","name":"parameter","type":"co.IParameter","doc":""}]},{"name":"co.Port","kind":"component","doc":"\n\n\tImplements co.IPort.\n\t---\n\ttags: private type-introspection\n ","members":[{"kind":"facet","name":"port","type":"co.IPort","doc":""}]},{"name":"co.ServiceManager","kind":"component","doc":"\n\n\tImplements co.IServiceManager.\n\t---\n\ttags: private component-model\n ","members":[{"kind":"facet","name":"serviceManager","type":"co.IServiceManager","doc":""}]},{"name":"co.Struct","kind":"component","doc":"\n\n\tImplements co.IStruct.\n\t---\n\ttags: private type-introspection\n ","members":[{"kind":"facet","name":"type","type":"co.IStruct","doc":""}]},{"name":"co.System","kind":"component","doc":"\n\n\tImplements co.ISystem.\n\t---\n\ttags: private system\n ","members":[{"kind":"facet","name":"system","type":"co.ISystem","doc":""}]},{"name":"co.SystemState","kind":"enum","doc":"\n\n\tEnumeration of states in the system's life cycle.\n\n\tThe two main system states are _nil_ (uninitialized) and _running_ (fully\n\tfunctional). All the other states are transient and only observable during\n\tthe system's setup and teardown.\n\t---\n\ttags: system\n ","identifiers":[{"id":"SystemState_None","doc":"\n Pre-initialization state. Only the Coral module is available."},{"id":"SystemState_Initializing","doc":"\n Modules are loading. They cannot interact yet."},{"id":"SystemState_Integrating","doc":"\n Modules are initialized and can now interact with each other."},{"id":"SystemState_Integrated","doc":"\n Modules are integrated and functional (without presentation)."},{"id":"SystemState_IntegratingPresentation","doc":"\n Modules are setting up their presentation."},{"id":"SystemState_Running","doc":"\n The system is running. The presentation is live."},{"id":"SystemState_Disintegrating","doc":"\n The system is being torn down."}]},{"name":"co.Type","kind":"component","doc":"\n\n\tImplements co.IType.\n\t---\n\ttags: private type-introspection\n ","members":[{"kind":"facet","name":"type","type":"co.IType","doc":""}]},{"name":"co.TypeBuilder","kind":"component","doc":"\n\n\tImplements co.ITypeBuilder.\n\t---\n\ttags: private type-creation\n ","members":[{"kind":"facet","name":"typeBuilder","type":"co.ITypeBuilder","doc":""}]},{"name":"co.TypeKind","kind":"enum","doc":"\n\n\tEnumeration of Coral type kinds.\n\n\tSee also: co.IType.\n\n\t---\n\ttags: type-system\n ","identifiers":[{"id":"TK_NULL","doc":" Null value."},{"id":"TK_BOOL","doc":" Boolean value."},{"id":"TK_INT8","doc":" 8-bit signed integer."},{"id":"TK_INT16","doc":" 16-bit signed integer."},{"id":"TK_INT32","doc":" 32-bit signed integer."},{"id":"TK_UINT8","doc":" 8-bit unsigned integer."},{"id":"TK_UINT16","doc":" 16-bit unsigned integer."},{"id":"TK_UINT32","doc":" 32-bit unsigned integer."},{"id":"TK_FLOAT","doc":" 32-bit IEEE 754 floating-point number."},{"id":"TK_DOUBLE","doc":" 64-bit IEEE 754 floating-point number."},{"id":"TK_ENUM","doc":" Enumeration of identifiers. See co.IEnum."},{"id":"TK_STRING","doc":" 8-bit clean string."},{"id":"TK_ANY","doc":" Coral's variant type."},{"id":"TK_ARRAY","doc":" One-dimensional array of elements. See co.IArray."},{"id":"TK_STRUCT","doc":" Set of named fields of various types. See co.IStruct."},{"id":"TK_NATIVECLASS","doc":" Native C++ value type. See co.INativeClass."},{"id":"TK_INTERFACE","doc":" Interface type. See co.IInterface."},{"id":"TK_COMPONENT","doc":" Component type. See co.IComponent."},{"id":"TK_EXCEPTION","doc":" Exception raised by methods. See co.IException."}]},{"name":"co.TypeLoadException","kind":"exception","doc":"\n\n\tRaised when an error occurs while loading a type.\n\t---\n\ttags: exception\n "},{"name":"co.TypeManager","kind":"component","doc":"\n\n\tImplements co.ITypeManager.\n\t---\n\ttags: private type-system\n ","members":[{"kind":"facet","name":"typeManager","type":"co.ITypeManager","doc":""}]},{"name":"co.TypeTransaction","kind":"component","doc":"\n\n\tImplements co.ITypeTransaction.\n\t---\n\ttags: private type-creation\n ","members":[{"kind":"facet","name":"transaction","type":"co.ITypeTransaction","doc":""}]},{"name":"co.Uuid","kind":"native class","doc":"\n\n\tA 128-bit Universally Unique IDentifier (UUID).\n\t---\n\ttags: deprecated\n ","members":[{"kind":"field","name":"isNull","type":"bool","isReadOnly":true,"doc":"\n True if this is the null UUID (that is, \"00000000-0000-0000-0000000000000000\")."},{"kind":"method","name":"clear","returnType":"void","doc":"\n Makes this Uuid a null UUID.","parameters":[],"exceptions":[]},{"kind":"method","name":"createRandom","returnType":"void","doc":"\n! Creates a new random Uuid.","parameters":[],"exceptions":[]},{"kind":"method","name":"createSha1","returnType":"void","doc":"\n! Creates an Uuid based on the SHA-1 hash of the specified data string.","parameters":[{"name":"data","type":"string","mode":"in"}],"exceptions":[]},{"kind":"method","name":"getString","returnType":"void","doc":"\n\n\t\tReturns the string representation of this Uuid. UUIDs are formatted according to the\n\t\tpattern \"xxxxxxxx-xxxx-xxxx-xxxxxxxxxxxxxxxx\", where 'x' is an hexadecimal digit.\n\t ","parameters":[{"name":"str","type":"string","mode":"out"}],"exceptions":[]},{"kind":"method","name":"setString","returnType":"void","doc":"\n\n\t\tSets the contents of this Uuid based on a string formatted according to the pattern\n\t\t\"{xxxxxxxx-xxxx-xxxx-xxxxxxxxxxxxxxxx}\", where 'x' is an hexadecimal digit.\n\t\tThe curly braces shown here are optional, but it is safe to include them.\n\t\tIf the string is malformed, the Uuid will become null.\n\t ","parameters":[{"name":"str","type":"string","mode":"in"}],"exceptions":[]}],"cpp":"\n\n\t\t#include <co/reserved/Uuid.h>\n\n\t"}]}